# Based on the generic template provided by Amazon:
# https://github.com/aws-samples/aws-secrets-manager-rotation-lambdas

import base64
import boto3
import hashlib
import http.client
import hmac
import json
import logging
import os
import time

from botocore.exceptions import ClientError

logger = logging.getLogger()
logger.setLevel(logging.INFO)

organization = os.environ['ORGANIZATION_SLUG']
project = os.environ['PROJECT_SLUG']
key_name = os.environ['CLIENT_KEY_NAME']

def lambda_handler(event, context):
    """Access key rotation lambda

    Args:
        event (dict): Lambda dictionary of event parameters. These keys must include the following:
            - SecretId: The secret ARN or identifier
            - ClientRequestToken: The ClientRequestToken of the secret version
            - Step: The rotation step (one of createSecret, setSecret, testSecret, or finishSecret)

        context (LambdaContext): The Lambda runtime information

    Raises:
        ResourceNotFoundException: If the secret with the specified arn and stage does not exist

        ValueError: If the secret is not properly configured for rotation

        KeyError: If the event parameters do not contain the expected keys

    """
    arn = event['SecretId']
    token = event['ClientRequestToken']
    step = event['Step']

    # Setup the client
    service_client = boto3.client('secretsmanager', endpoint_url=os.environ['SECRETS_MANAGER_ENDPOINT'])

    # Make sure the version is staged correctly
    metadata = service_client.describe_secret(SecretId=arn)
    if not metadata['RotationEnabled']:
        logger.error("Secret %s is not enabled for rotation" % arn)
        raise ValueError("Secret %s is not enabled for rotation" % arn)
    versions = metadata['VersionIdsToStages']
    if token not in versions:
        logger.error("Secret version %s has no stage for rotation of secret %s." % (token, arn))
        raise ValueError("Secret version %s has no stage for rotation of secret %s." % (token, arn))
    if "AWSCURRENT" in versions[token]:
        logger.info("Secret version %s already set as AWSCURRENT for secret %s." % (token, arn))
        return
    elif "AWSPENDING" not in versions[token]:
        logger.error("Secret version %s not set as AWSPENDING for rotation of secret %s." % (token, arn))
        raise ValueError("Secret version %s not set as AWSPENDING for rotation of secret %s." % (token, arn))

    if step == "createSecret":
        create_secret(service_client, arn, token)

    elif step == "setSecret":
        set_secret(service_client, arn, token)

    elif step == "testSecret":
        test_secret(service_client, arn, token)

    elif step == "finishSecret":
        finish_secret(service_client, arn, token)

    else:
        raise ValueError("Invalid step parameter")


def create_secret(service_client, arn, token):
    """Create the secret

    Create a new client key with the alternate name from the current client key. If a client key
    with the same name already exists, it will be deleted first.

    Args:
        service_client (client): The secrets manager service client

        arn (string): The secret ARN or other identifier

        token (string): The ClientRequestToken associated with the secret version

    Raises:
        ResourceNotFoundException: If the secret with the specified arn and stage does not exist

    """

    # Make sure the current secret exists
    current_secret = get_secret_dict(service_client, arn, "AWSCURRENT")
    create_key_name = get_alt_key(current_secret)

    # Check to see if we already have a value for this version of the secret
    try:
        # If we do, return it
        service_client.get_secret_value(SecretId=arn, VersionId=token, VersionStage="AWSPENDING")
        logger.info("createSecret: Successfully retrieved secret for %s." % arn)
    except service_client.exceptions.ResourceNotFoundException:
        # Delete any keys with the same name
        delete_sentry_client_key(service_client, create_key_name)

        # Create a client key
        result = create_sentry_client_key(service_client, create_key_name)
        client_key = result['dsn']['public']
        current_secret['SENTRY_DSN'] = client_key
        current_secret['SENTRY_KEY_NAME'] = create_key_name

        # Put the secret
        service_client.put_secret_value(SecretId=arn, ClientRequestToken=token, SecretString=json.dumps(current_secret), VersionStages=['AWSPENDING'])
        logger.info("createSecret: Successfully put secret for ARN %s and version %s." % (arn, token))

def set_secret(service_client, arn, token):
    """Set the secret

    You can't generate your own lcient keys (they are generated by Sentry),
    which means the access key already exists and there is nothing to set at
    this stage.

    Args:
        service_client (client): The secrets manager service client

        arn (string): The secret ARN or other identifier

        token (string): The ClientRequestToken associated with the secret version

    """
    pass


def test_secret(service_client, arn, token):
    """Test the secret

    Validate that the secret value authenticates as the expected user.

    Args:
        service_client (client): The secrets manager service client

        arn (string): The secret ARN or other identifier

        token (string): The ClientRequestToken associated with the secret version

    """

    # Get the pending version of the secret
    logger.info("testSecret: fetching AWSPENDING stage of version %s for secret %s." % (token, arn))
    pending = get_secret_dict(service_client, arn, "AWSPENDING", token)

    # Verify that a client key exists with the expected name and DSN
    check_sentry_client_key(service_client, pending)

def finish_secret(service_client, arn, token):
    """Finish the secret

    This method finalizes the rotation process by marking the secret version
    passed in as the AWSCURRENT secret.

    Args:
        service_client (client): The secrets manager service client

        arn (string): The secret ARN or other identifier

        token (string): The ClientRequestToken associated with the secret version

    Raises:
        ResourceNotFoundException: If the secret with the specified arn does not exist

    """
    # First describe the secret to get the current version
    metadata = service_client.describe_secret(SecretId=arn)
    current_version = None
    for version in metadata["VersionIdsToStages"]:
        if "AWSCURRENT" in metadata["VersionIdsToStages"][version]:
            if version == token:
                # The correct version is already marked as current, return
                logger.info("finishSecret: Version %s already marked as AWSCURRENT for %s" % (version, arn))
                return
            current_version = version
            break

    # Finalize by staging the secret version current
    service_client.update_secret_version_stage(SecretId=arn, VersionStage="AWSCURRENT", MoveToVersionId=token, RemoveFromVersionId=current_version)
    logger.info("finishSecret: Successfully set AWSCURRENT stage to version %s for secret %s." % (token, arn))

def get_secret_dict(service_client, arn, stage, token=None):
    """Gets the secret dictionary corresponding for the secret arn, stage, and token
    This helper function gets credentials for the arn and stage passed in and returns the dictionary by parsing the JSON string
    Args:
        service_client (client): The secrets manager service client
        arn (string): The secret ARN or other identifier
        token (string): The ClientRequestToken associated with the secret version, or None if no validation is desired
        stage (string): The stage identifying the secret version
    Returns:
        SecretDictionary: Secret dictionary
    Raises:
        ResourceNotFoundException: If the secret with the specified arn and stage does not exist
        ValueError: If the secret is not valid JSON
        KeyError: If the secret json does not contain the expected keys
    """
    required_fields = ['SENTRY_DSN', 'SENTRY_KEY_NAME']

    # Only do VersionId validation against the stage if a token is passed in
    if token:
        secret = service_client.get_secret_value(SecretId=arn, VersionId=token, VersionStage=stage)
    else:
        secret = service_client.get_secret_value(SecretId=arn, VersionStage=stage)
    plaintext = secret['SecretString']
    secret_dict = json.loads(plaintext)

    for field in required_fields:
        if field not in secret_dict:
            raise KeyError("%s key is missing from secret JSON" % field)

    # Parse and return the secret JSON string
    return secret_dict

def check_sentry_client_key(service_client, secret):
    api_key = get_api_key(service_client)
    expected_key_name = secret['SENTRY_KEY_NAME']
    dsn = secret['SENTRY_DSN']
    keys = sentry_request(api_key, "GET", "/projects/%s/%s/keys/" % (organization, project))
    existing = get_sentry_client_key(service_client, expected_key_name)
    if existing == None:
        raise ValueError('No key for %s/%s named %s' % (organization, project, expected_key_name))
    if existing['dsn']['public'] == dsn:
        logger.info("Found expected client key %s for %s/%s." % (expected_key_name, organization, project))
        return
    else:
        raise ValueError('Unexpected DSN for key %s for %s/%s', (expected_key_name, organization, project))

def create_sentry_client_key(service_client, create_key_name):
    api_key = get_api_key(service_client)
    body = json.dumps({'name':create_key_name})
    response =  sentry_request(api_key, "POST", "/projects/%s/%s/keys/" % (organization, project), body)
    logger.info("Created client key %s for %s/%s." % (create_key_name, organization, project))
    return response

def delete_sentry_client_key(service_client, delete_key_name):
    api_key = get_api_key(service_client)
    existing = get_sentry_client_key(service_client, delete_key_name)
    if existing == None:
        logger.info("No existing client key %s for %s/%s." % (delete_key_name, organization, project))
        return

    key_id = existing['id']
    response = sentry_request(api_key, "DELETE", "/projects/%s/%s/keys/%s/" % (organization, project, key_id))
    logger.info("Deleted client key %s for %s/%s." % (delete_key_name, organization, project))
    return response

def get_sentry_client_key(service_client, expected_key_name):
    api_key = get_api_key(service_client)
    keys = sentry_request(api_key, "GET", "/projects/%s/%s/keys/" % (organization, project))
    matching = [key for key in keys if key['name'] == expected_key_name]
    if matching == []:
        return None
    else:
        return matching[0]

def get_alt_key(secret):
    if secret['SENTRY_KEY_NAME'] == key_name:
        return "%s-alt" % key_name
    else:
        return key_name


def get_api_key(service_client):
    secret_arn = os.getenv('AUTH_TOKEN_SECRET_ARN')
    secret_key = os.getenv('AUTH_TOKEN_SECRET_KEY')
    secret = service_client.get_secret_value(SecretId=secret_arn, VersionStage="AWSCURRENT")
    plaintext = secret['SecretString']
    data = json.loads(plaintext)
    return data[secret_key]


def sentry_request(api_key, method, path, body=None):
    connection = http.client.HTTPSConnection('sentry.io', 443, timeout=10)
    headers = { "Authorization": "Bearer %s" % api_key, "Content-Type": "application/json" }
    connection.request(method, "/api/0%s" % path, body=body, headers=headers)
    response = connection.getresponse()
    body = response.read()
    connection.close()
    if body == b'':
        return None

    try:
        return json.loads(body)
    except json.decoder.JSONDecodeError:
        raise ValueError('Unable to decode response: %s' % body)
